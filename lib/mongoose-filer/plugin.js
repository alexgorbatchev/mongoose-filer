// Generated by CoffeeScript 1.3.3
(function() {
  var AttachedFile, Attachments, async, exports, mongoose, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  async = require('async');

  mongoose = require('mongoose');

  _ = require('underscore');

  AttachedFile = require('./attached_file');

  Attachments = new mongoose.Schema({
    name: {
      type: String,
      required: true
    },
    fileName: String,
    contentType: String,
    createdAt: {
      type: Date,
      "default": Date.now
    }
  }, {
    strict: true
  });

  Attachments.virtual('file').get(function() {
    return this._file;
  }).set(function(value) {
    return this._file = value;
  });

  Attachments.virtual('config').get(function() {
    return this.parent.schema.attachments[this.name];
  });

  Attachments.virtual('attachedFile').get(function() {
    var _ref;
    return (_ref = this._attachedFile) != null ? _ref : this._attachedFile = new AttachedFile(this.parent.id, {
      modelName: this.parent.constructor.modelName,
      attributeName: this.name,
      fileName: this.fileName,
      styles: this.config.styles,
      file: {
        name: this.fileName,
        type: this.contentType,
        path: this.file
      }
    });
  });

  Attachments.path('contentType').validate(function(v) {
    var contentTypes, _ref;
    contentTypes = (_ref = this.parent) != null ? _ref.schema.attachments[this.name].contentType : void 0;
    return !(contentTypes != null) || (__indexOf.call(contentTypes, v) >= 0);
  }, "acceptable content type");

  Attachments.method({
    url: function(style) {
      return this.attachedFile.url(style);
    },
    toObject: function(options) {
      var json, style, styles;
      json = mongoose.Model.prototype.toObject.call(this, options);
      if (options.client) {
        styles = _.extend({
          original: ''
        }, this.config.styles);
        for (style in styles) {
          if (!__hasProp.call(styles, style)) continue;
          options = styles[style];
          json[style] = {
            url: this.url(style)
          };
        }
      }
      return json;
    }
  });

  Attachments.pre('save', function(next) {
    if (!(this.isNew && (this.file != null))) {
      return next();
    }
    return this.attachedFile.save(next);
  });

  exports = module.exports = function(schema, options) {
    var name;
    name = options.name;
    schema.attachments || (schema.attachments = {});
    schema.attachments[name] = options;
    if (!schema.path('attachments')) {
      schema.add({
        'attachments': [Attachments]
      });
    }
    schema.virtual(name).get(function() {
      return _(this.attachments).find(function(a) {
        return a.name === name;
      });
    });
    schema.virtual(name).set(function(value) {
      var existing;
      (existing = this.get(name)) && existing.remove();
      if (value.path != null) {
        return this.attachments.push({
          name: name,
          fileName: value.name,
          contentType: value.type,
          file: value.path
        });
      } else {
        value.name = name;
        return this.attachments.push(value);
      }
    });
    if (options.required) {
      return schema.pre('save', function(next) {
        if (this.get(name) != null) {
          return next();
        }
        this.invalidate(name, 'required');
        return next(this._validationError);
      });
    }
  };

  exports.Attachment = mongoose.model('Attachment', Attachments);

}).call(this);
